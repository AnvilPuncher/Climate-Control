
package climateControl.customGenLayer;

import climateControl.ClimateControl;
import climateControl.genLayerPack.GenLayerPack;
import climateControl.generator.Decoder;
import climateControl.generator.Encoder;
import climateControl.utils.Function;
import climateControl.utils.KeyedRegistry;
import climateControl.utils.PlaneLocated;
import climateControl.utils.PlaneLocation;
import java.util.ArrayList;
import net.minecraft.world.gen.layer.GenLayer;
import net.minecraft.world.gen.layer.IntCache;

/**
 *
 * @author Zeno410
 */
public class EncodedZoom extends GenLayerPack
{
    private static final String __OBFID = "CL_00000572";
    private final Decoder biomeEncoder;
    private Choices hits = new Choices();
    private PlaneLocated<Integer> values = new PlaneLocated<Integer>();
    private PlaneLocated<Choices> choices = new PlaneLocated<Choices>();

    public EncodedZoom(long par1, GenLayer par3GenLayer, Decoder biomeEncoder) {
        super(par1);
        super.parent = par3GenLayer;
        this.biomeEncoder = biomeEncoder;
    }

    /**
     * Returns a list of integer values generated by this layer. These may be interpreted as temperatures, rainfall
     * amounts, or biomeList[] indices based on the particular GenLayer subclass.
     */
    public int[] getUnsafeInts(int par1, int par2, int par3, int par4)
    { // this is based on the vanilla procedure and seems to produce inconsistencies
        int i1 = par1 >> 1;
        int j1 = par2 >> 1;
        int k1 = (par3 >> 1) + 2;
        int l1 = (par4 >> 1) + 2;
        int[] aint = this.parent.getInts(i1, j1, k1, l1);
        int i2 = k1 - 1 << 1;
        int j2 = l1 - 1 << 1;
        int[] aint1 = IntCache.getIntCache(i2 * j2);
        int l2;

        for (int k2 = 0; k2 < l1 - 1; ++k2)
        {
            l2 = (k2 << 1) * i2;
            int i3 = 0;
            int j3 = aint[i3 + 0 + (k2 + 0) * k1];

            for (int k3 = aint[i3 + 0 + (k2 + 1) * k1]; i3 < k1 - 1; ++i3)
            {
                this.initChunkSeed((long)(i3 + i1), (long)(k2 + j1));
                int l3 = aint[i3 + 1 + (k2 + 0) * k1];
                int i4 = aint[i3 + 1 + (k2 + 1) * k1];
                aint1[l2] = j3;
                aint1[l2++ + i2] = this.selectRandom(new int[] {j3, k3});
                aint1[l2] = this.selectRandom(new int[] {j3, l3});
                aint1[l2++ + i2] = this.fastSelectEncodedModeOrRandom(j3, l3, k3, i4);
                j3 = l3;
                k3 = i4;
            }
        }

        int[] aint2 = IntCache.getIntCache(par3 * par4);

        for (l2 = 0; l2 < par4; ++l2)
        {
            System.arraycopy(aint1, (l2 + (par2 & 1)) * i2 + (par1 & 1), aint2, l2 * par3, par3);
        }

        return aint2;
    }

    public int [] getInts(int x0, int z0, int width, int height) {
        if (1>0) {
            return getUnsafeInts(x0,z0,width,height);
        }
        int evenX0;
        if (x0>=0) {
            evenX0 = 2*(x0/2);
        } else {
            evenX0 = 2*((x0-1)/2);
        }
        int evenZ0;
        if (z0>=0) {
            evenZ0 = 2*(z0/2);
        } else {
            evenZ0 = 2*((z0-1)/2);
        }

        int oddWidth = oddPositive(width + (x0-evenX0));
        int oddHeight = oddPositive(height +(z0-evenZ0));

        int [] internals = getIntsInternal(evenX0, evenZ0, oddWidth,  oddHeight);

        int [] result = IntCache.getIntCache(width*height);
        int xOffset = x0 - evenX0;
        int zOffset = z0 - evenZ0;
        for (int x = 0; x< width; x++) {
            for (int z = 0; z<height; z++) {
                result[x+z*width] = internals[x+xOffset+(z+zOffset)*oddWidth];
            }
        }
        return result;
    }

    public static final int oddPositive(int number) {
        return 2*(number/2)+1;
    }

    private void confirm(int x, int z, int value) {
        PlaneLocation location = new PlaneLocation(x,z);
        Integer existing = values.get(location);
        if (existing == null) {
            values.put(location, value);
        } else {
            if (existing != value) {
                throw new RuntimeException(location.toString()+existing+" to "+value);
            }
        }
    }

    private void confirmChoices(int x, int z, Choices value) {
        PlaneLocation location = new PlaneLocation(x,z);
        Choices existing = choices.get(location);
        if (existing == null) {
            choices.put(location, value);
        } else {
            if (!existing.equals(value)) {
                //ClimateControl.logger.info(existing.description() )
                throw new RuntimeException(location.toString()+existing.description()+" to "+value.description());
            }
        }
    }
    public int[] getIntsInternal(int evenX0, int evenZ0, int oddWidth, int oddHeight) {
        // gets the appropriate value from a call set up to work normally
        int i1 = evenX0 >> 1;
        int j1 = evenZ0 >> 1;
        int k1 = (oddWidth >> 1) + 2;
        int l1 = (oddHeight >> 1) + 2;
        int[] aint = this.parent.getInts(i1, j1, k1, l1);
        int i2 = k1 - 1 << 1;
        int j2 = l1 - 1 << 1;
        int[] aint1 = IntCache.getIntCache(i2 * j2);
        int l2;

        // place direct parents
        for (int x = 0; x<oddWidth ; x = x+2) {
            for (int z = 0; z<oddHeight ; z = z+2) {
                aint1[x+z*oddWidth] = aint[x/2 + 0 + (z/2 + 0) * k1];
            }
        }

        // interpolations
        // vertical spar
        for (int x = 0; x<oddWidth ; x = x+2) {
            for (int z = 0; z<oddHeight-2 ; z = z+2) {
                // horizontal spar
                int top = aint1[x+z*oddWidth];
                int bottom = aint1[x+(z+2)*oddWidth];
                if (top == bottom) {
                    aint1[x+(z+1)*oddWidth] = top;
                } else {
                    this.initChunkSeed((long)(evenX0+x), (long)(evenZ0+z+1));
                    if (nextInt(2)==0) {
                        aint1[x+(z+1)*oddWidth] = top;
                    } else {
                        aint1[x+(z+1)*oddWidth] = bottom;
                    }
                }
            }
        }
        //horizontal sparr
        for (int x = 0; x<oddWidth-2 ; x = x+2) {
            for (int z = 0; z<oddHeight ; z = z+2) {
                int left = aint1[x+z*oddWidth];
                int right = aint1[x+2+(z)*oddWidth];
                if (left == right) {
                    aint1[x+1+(z)*oddWidth] = left;
                } else {
                    this.initChunkSeed((long)(evenX0+x+1), (long)(evenZ0+z));
                    if (nextInt(2)==0) {
                        aint1[x+1+(z)*oddWidth] = left;
                    } else {
                        aint1[x+1+(z)*oddWidth] = right;
                    }
                }
            }
        }
        //center hole
        for (int x = 0; x<oddWidth-2 ; x = x+2) {
            for (int z = 0; z<oddHeight-2 ; z = z+2) {
                int topleft = aint1[x+z*oddWidth];
                int topright = aint1[x+2+(z)*oddWidth];
                int bottomleft= aint1[x+(z+2)*oddWidth];
                int bottomright = aint1[x+2+(z+2)*oddWidth];
                this.initChunkSeed((long)(evenX0+x+1), (long)(evenZ0+z+1));
                aint1[x+1+(z+1)*oddWidth] = this.fastSelectEncodedModeOrRandom(topleft, bottomleft, topright, bottomright);
                //Choices lastChoices = hits.copy();
                //confirmChoices(evenX0+x+1,evenZ0+z+1,lastChoices);
            }
        }

        for (int x = 0; x< oddWidth; x++) {
            for (int z = 0; z< oddHeight;z++) {
                //confirm(x+evenX0,z+evenZ0,aint1[x+z*oddWidth]);
            }
        }
        return aint1;
    }
    private final int decoded(int code) {
        try {
            return this.biomeEncoder.decode(code);
        } catch (RuntimeException e) {
            throw new RuntimeException("code "+code);
        }
    }
    
    private static Function<Integer,ArrayList<Integer>> intListMaker = new Function<Integer,ArrayList<Integer>>() {

        @Override
        public ArrayList<Integer> result(Integer source) {
            return new ArrayList<Integer>();
        }
        
    };

    protected int SelectEncodedModeOrRandom(int top, int left, int right, int bottom){
        KeyedRegistry<Integer,ArrayList<Integer>> hits =
                new KeyedRegistry<Integer,ArrayList<Integer>> (intListMaker);


        hits.item(decoded(top)).add(top);
        hits.item(decoded(left)).add(left);
        hits.item(decoded(right)).add(right);
        hits.item(decoded(bottom)).add(bottom);

        if (hits.size() == 4) {
            // all different
            int choice = nextInt(4);
            if (choice ==0 ) return top;
            if (choice ==1) return left;
            if (choice == 2) return right;
            return bottom;
        }
        // implied else due to returns;
        // we now have some duplicates; either one best or two equal
        ArrayList<Integer> choices = null;
        int oldCount = 0;
        for (ArrayList<Integer> hit: hits.values()) {
            if (choices == null) {
                choices = hit;
                oldCount = choices.size();
                continue;
            }
            // implied else
            int newCount = hit.size();
            // skip if smaller
            if (newCount < oldCount) continue;
            // change if bigger
            if (newCount > oldCount) {
                choices = hit;
                oldCount = choices.size();
            } else {
                // if size 1 it will be replaced later
                if (newCount==1) continue;
                // two pairings and surprisingly it's a random choice
                int choice = nextInt(4);
                if (choice ==0 ) return top;
                if (choice ==1) return left;
                if (choice == 2) return right;
                return bottom;
            }
        }
        // random member of largest set
        return choices.get(nextInt(choices.size()));
    }

    protected int fastSelectEncodedModeOrRandom(int top, int left, int right, int bottom){

        hits.clear();
        hits.item(decoded(top)).add(top);
        hits.item(decoded(left)).add(left);
        hits.item(decoded(right)).add(right);
        hits.item(decoded(bottom)).add(bottom);

        if (hits.size() == 4) {
            // all different
            int choice = nextInt(4);
            if (choice ==0 ) return top;
            if (choice ==1) return left;
            if (choice == 2) return right;
            return bottom;
        }
        // implied else due to returns;
        // we now have some duplicates; either one best or two equal

        return hits.mostCommon();
    }

    private class Choices {
        int count = 0;
        UpToFour [] values = new UpToFour[4];

        Choices() {
            for (int i = 0; i < 4; i++) {
                values[i] = new UpToFour();
            }
        }

        void clear() {
            count = 0;
        }

        int totalItems() {
            int result = 0;
            for (int i = 0; i < count; i++) {
                result += values[i].size();
            }
            return result;

        }
        int size() {return count;}

        UpToFour item(int value) {
            for (int i = 0; i < count; i++) {
                if (values[i].value == value) return values[i];
            }
            values[count].setValue(value);
            return values[count++];
        }

        int mostCommon() {
            UpToFour choices = values[0];
            int oldCount = choices.count;
            for (int i = 1; i <3; i++) {
                // implied else
                int newCount = values[i].size();
                // skip if smaller
                if (newCount < oldCount) continue;
                // change if bigger
                if (newCount > oldCount) {
                    choices = values[i];
                    oldCount = choices.size();
                } else {
                    // if size 1 it will be replaced later
                    if (newCount==1) continue;
                    // two pairings and surprisingly it's a random choice
                    int choice = nextInt(4);
                    if (choice ==0 ) return values[0].items[0];
                    if (choice ==1) return values[0].items[1];
                    if (choice == 2) return values[1].items[0];;
                    return values[1].items[1];
                }
            }
            // we have a largest member
            // random member of largest set
            return choices.items[nextInt(choices.size())];
        }

        @Override
        public boolean equals(Object compared) {
            if (!(compared instanceof Choices)) return false;
            Choices comparedChoices = (Choices)compared;
            if (this.count != comparedChoices.count) return false;
            for (int i = 0; i < count; i++) {
                if (this.values[i].count != comparedChoices.values[i].count) return false;
                if (this.values[i].value != comparedChoices.values[i].value) return false;
                for (int j = 0; j < this.values[i].count; j++) {
                    if (this.values[i].items[j] != comparedChoices.values[i].items[j]) return false;
                }
            }
            return true;
        }

        public String description() {
            String result = "";
            for (int i = 0; i < count; i++) {
                result += this.values[i].value+";";
                for (int j = 0; j < this.values[i].count; j++) {
                    result += this.values[i].items[j]+",";
                }
            }
            return result;
        }
        
        Choices copy() {
            Choices result = new Choices();
            for (int i = 0; i < this.count; i++) {
                for (int j = 0; j< this.values[i].count; j++) {
                    result.item(this.values[i].value).add(this.values[i].items[j]);
                }
            }
            return result;
        }
    }

    private class UpToFour {
        int count = 0;
        int value;
        int [] items = new int[4];
        void setValue(int newValue) {
            value = newValue;
            count = 0;
        }
        void clear() {count = 0;}
        void add(int added) {
            items[count]=added;
            count++;
        }
        int size() {return count;}
    }
}
